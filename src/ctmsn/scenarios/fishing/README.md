# Fishing (4.14)

## Описание задачи

Рыбалка — процесс "поймать рыбу" через крючок/наживку, с разделением рыб на свободных и пойманных, и червей на настоящих/фальшивых.

## Домены и объекты

- `A`, `B` — состояния/этапы процесса
- `F` — рыбы (Fish)
- `F_plus` (F⁺) — улов (пойманные рыбы)
- `F_minus` (F⁻) — свободные рыбы, канонически: F_minus = F \ F_plus
- `W` — черви (Worm)
- `W_plus` (W⁺) — фальшивые черви (наживка на крючке)
- `Cf_minus` (C_f⁻) — контекст "нет улова на крючок; рыбы едят настоящих червей"
- `Cf_plus` (C_f⁺) — контекст "улов на крючок; пойманная на наживку рыба"

## Морфизмы (стрелки)

- `f: B → A` — развитие события от B к A
- `h: A → F` — "рыбка" (пунктир)
- `s: A → F_minus` — "не пойманная рыба"
- `j: A → F_plus` — "пойманная рыба"
- `g_minus: F → F_minus` — отделение свободных
- `g_plus: F → F_plus` — отделение пойманных
- `catch: F_minus → F_plus` — "поймать" (пунктир)
- `sf: B → Cf_minus` — переход в контекст свободных рыб
- `eat: Cf_minus → W` — "рыбы едят червей"
- `fake_plus: W → W_plus` — фальсификация червей
- `fake_minus: W → W` — проверка (полинность)
- `hook_plus: W_plus → Cf_plus` — наживка на крючке, ведущая в контекст улова
- `hook_minus: W → Cf_minus` — настоящий червь в свободном контексте
- `incl: Cf_minus → F_minus` — включение контекста
- `incl: Cf_plus → F_plus` — включение контекста
- `catch_sf: B → Cf_plus` — результирующая стрелка композиции

## Канонические равенства (цели)

1. Разность множеств: `F_minus = F \ F_plus`

2. "Съел наживку и попал на крючок, стал вести себя как пойманная рыба":
   ```
   hook_plus ∘ fake_plus ∘ eat ∘ sf = catch ∘ sf
   ```

3. "Стало вести себя как j":
   ```
   catch ∘ s = j
   ```

4. Поведенческие равенства:
   ```
   g_minus ∘ h = s
   g_plus ∘ h = j
   ```

## Структура реализации

- `model.py` — граф (только edge, без comp)
- `derive.py` — вывод comp2 и compN
- `constraints.py` — условия-равенства из подписи
- `goal.py` — цель (те же равенства как формула)
- `explain.py` — форматирование доказательств
- `runner.py` — полный цикл: build → derive → check/forces → explain

## Особенности

В этой задаче:
- **Нет прямых comp** в модели — всё выводится через пути
- **Длинная композиция** (4 шага) с именованным результатом `catch_sf`
- **Материализация** композиции как `derived_edge` для будущего forcing
- **Trace** с промежуточными узлами для каждого равенства
